#!/opt/anaconda/envs/env_ewf_satcen_03_01_01/bin/python

# This node gets input refrences and run-time params 
# Controls if master/s and slave/s are valid
# Publishes dict-format data containing master/s & slave/s selves & subswath & polarisation params 


import os
import sys
sys.path.append('/'.join([os.environ['_CIOP_APPLICATION_PATH'], 'util']))
sys.path.append('../util')


from util import *
import json
import string
import atexit
import itertools
import cioppy 
ciop = cioppy.Cioppy()
import pandas as pd    
# define the exit codes
SUCCESS = 0
ERR_RESOLUTION = 10
ERR_STAGEIN = 20
ERR_NO_OUTPUT = 30
ERR_OVERLAP = 40
ERR_PRODUCT_TYPE = 50
ERR_TRACK = 60
ERR_POLARISATION = 70

# add a trap to exit gracefully
def clean_exit(exit_code):
    log_level = 'INFO'
    if exit_code != SUCCESS:
        log_level = 'ERROR'  
   
    msg = {SUCCESS: 'Processing successfully concluded',
           ERR_RESOLUTION: 'Could not resolve Sentinel-1 product enclosure',
           ERR_STAGEIN: 'Could not stage-in Sentinel-1 product', 
           ERR_OVERLAP: 'At least one of the products does not overlap against the selected AOI or the two products do not overlap themselves',
           ERR_PRODUCT_TYPE: 'At least one of the products is not a SLC image',
           ERR_TRACK: 'Products do not have the same track',
           ERR_POLARISATION: 'Products do not have the same polarisation',
           ERR_NO_OUTPUT: "Missing output"}
 
    ciop.log(log_level, msg[exit_code])  

def main():
        
    ciop = cioppy.Cioppy()
    
    os.chdir(ciop.tmp_dir)
    
    #aoi = ciop.getparam('aoi')

    polarizations = list(ciop.getparam('polarisation'))
    sub_swaths = list(ciop.getparam('subswath').split(' ')) 
    references = []
        
    for input in sys.stdin:
        ciop.log('INFO', 'Adding {}'.format(input.rstrip()))       
        references.append(input.rstrip().split(',')[0])
    
    input_products = pd.DataFrame()

    fields = 'identifier,self,enclosure,wkt,startdate,enddate,orbitDirection,productType,track,polarisationChannels'
    search_result_params = []
    for index, end_point in enumerate(references):
        ciop.log('INFO', 'Getting metadata for {}'.format(end_point))      
        temp_df = pd.DataFrame.from_dict(ciop.search(end_point=end_point,
                                                     params=search_result_params,
                                                     output_fields=fields, 
                                                     model='EOP',
                                                     timeout='60000'))
        
        input_products = input_products.append(temp_df, ignore_index=True)
        
    #Verify Validity of input products for processing:
    group_analysis(input_products)
    
    if len(input_products.groupby('productType'))>1:
        sys.exit(ERR_PRODUCT_TYPE)
    
    if len(input_products.groupby('track'))>1:
        sys.exit(ERR_TRACK)
    
    if len(input_products.groupby('polarisationChannels'))>1:
        sys.exit(ERR_POLARISATION)
    
    #check to be applied for AOI overlap & products overlap
    #....to be added
    #....
    #....
    
    for k , pol in itertools.product(sub_swaths , polarizations):
        series = dict()
        series['master_ref'] = ','.join(input_products[input_products['ordinal_type'] == 'Pre'].self.values)
        series['slave_ref'] = ','.join(input_products[input_products['ordinal_type'] == 'Pst'].self.values)
        series['subswath'] = k
        series['polarization'] = pol
        
        #publish master/slave/subswath/pol and echo to next node 
        ciop.publish((json.dumps(series) + '\n'), mode="silent")


try:
    main()
except SystemExit as e:
    if e.args[0]:
        clean_exit(e.args[0])
    raise
else:
    atexit.register(clean_exit, 0)
