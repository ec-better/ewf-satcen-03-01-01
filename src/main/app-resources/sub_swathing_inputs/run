#!/opt/anaconda/envs/env_ewf_satcen_03_01_01/bin/python

import os
import sys
sys.path.append('/'.join([os.environ['_CIOP_APPLICATION_PATH'], 'util']))
sys.path.append('../util')

from snap import *
from util import *

import string
import atexit
import itertools
import cioppy 
ciop = cioppy.Cioppy()
    
# define the exit codes
SUCCESS = 0
ERR_RESOLUTION = 10
ERR_STAGEIN = 20
ERR_NO_OUTPUT = 30

# add a trap to exit gracefully
def clean_exit(exit_code):
    log_level = 'INFO'
    if exit_code != SUCCESS:
        log_level = 'ERROR'  
   
    msg = {SUCCESS: 'Processing successfully concluded',
           ERR_RESOLUTION: 'Could not resolve Sentinel-1 product enclosure',
           ERR_STAGEIN: 'Could not stage-in Sentinel-1 product', 
           ERR_OVERLAP: 'At least one of the products does not overlap against the selected AOI or the two products do not overlap themselves',
           ERR_PRODUCT_TYPE: 'At least one of the products is not a SLC image',
           ERR_TRACK: 'Products do not have the same track',
           ERR_POLARISATION: 'Products do not have the same polarisation',
           ERR_NO_OUTPUT: "Missing output"}
 
    ciop.log(log_level, msg[exit_code])  

def main():
        
    ciop = cioppy.Cioppy()
    
    os.chdir(ciop.tmp_dir)
    
    #aoi = ciop.getparam('aoi')

    polarizations = list(ciop.getparam('polarisation').split(','))
    sub_swaths = list(ciop.getparam('subswath').split(',')) 
    references = []
        
    for input in sys.stdin:
        ciop.log('INFO', 'Adding {}'.format(input.rstrip()))       
        references.append(input.rstrip().split(',')[0])
    
    input_products = pd.DataFrame()

    fields = 'identifier,self,enclosure,wkt,startdate,enddate,orbitDirection,productType,track,polarisationChannels'
    search_result_params = []
    for index, end_point in enumerate(references):
        ciop.log('INFO', 'Getting metadata for {}'.format(end_point))      
        temp_df = pd.DataFrame.from_dict(ciop.search(end_point=end_point,
                                                     params=search_result_params,
                                                     output_fields=fields, 
                                                     model='EOP',
                                                     timeout='60000'))
        
        input_products = input_products.append(temp_df, ignore_index=True)
        
    #Verify Validity of input products for processing:
    group_analysis(input_products)
    
    if len(input_products.groupby('productType'))>1:
        sys.exit(ERR_PRODUCT_TYPE)
    
    if len(input_products.groupby('Track'))>1:
        sys.exit(ERR_TRACK)
    
    if len(input_products.groupby('polarisationChannels'))>1:
        sys.exit(ERR_POLARISATION)
    
    #check to be applied for AOI overlap & products overlap
    #....to be added
    #....
    #....
    #Stage_IN:
    for product in input_products.iterrows():
        product.path = ciop.copy(product.enclosure,ciop.tmp_dir)
        ciop.log("INFO", "Product local path: " + product.path)
        product['local_path'] = "{0}/{1}.SAFE/manifest.safe".format(product.path,product.identifier)

    if len(input_products[input_products['ordinal_type'] == 'Pre'].index)==1:
        master_path = input_products[input_products['ordinal_type'] == 'Pre'].local_path
    else: 
        master_path = snap.slice_assembly(input_products[input_products['ordinal_type'] == 'Pst'].reset_index(drop=True))
        
        
    if len(input_products[input_products['ordinal_type'] == 'Pst'].index)==1:
        slave_path = input_products[input_products['ordinal_type'] == 'Pst'].local_path
    else: 
        slave_path = snap.slice_assembly(input_products[input_products['ordinal_type'] == 'Pre'].reset_index(drop=True))
        
        
    master_identifier = '_'.join(input_products[input_products['ordinal_type'] == 'Pre'].identifier.values)
    slave_identifier = '_'.join(input_products[input_products['ordinal_type'] == 'Pst'].identifier.values)

    for k , pol in itertools.product(subswaths , polarizations): 

        #TOPS Split products and write 
        slave_name='{}_{}_slv_{}.tif'.format(k,pol,slave_identifier)
        snap.split_subswath_write_product(slave_id,k,pol,os.path.join(ciop.tmp_dir,master_name))
        
        master_name='{}_{}_mstr_{}.tif'.format(k,pol,master_identifier)
        snap.split_subswath_write_product(master_id,k,pol,os.path.join(ciop.tmp_dir,master_name))
        
        #publish master & slave files and echo to next node 
        ciop.publish(list(slave_name,master_name),mode="silent" )


   


try:
    main()
except SystemExit as e:
    if e.args[0]:
        clean_exit(e.args[0])
    raise
else:
    atexit.register(clean_exit, 0)
